type Address = variant { EvmAddress : text };
type Caller = record { chain : Chain; address : Address };
type Chain = variant { Evm : EvmChain };
type Commit = record {
  title : text;
  fees : nat64;
  logs : vec LogEntry;
  instructions : nat64;
  timestamp : nat64;
};
type DeployResult = variant { Error : text; Duplicate : blob; Success : blob };
type EvmChain = variant { ArbitrumSepolia; ArbitrumOne; Localhost };
type FunctionDefinition = record {
  source : text;
  compiler : text;
  binary : blob;
};
type FunctionState = record {
  hash : blob;
  deployed_at : nat64;
  is_verified : bool;
  definition : FunctionDefinition;
};
type Job = record {
  status : JobStatus;
  base_fee : nat64;
  execution_fees : nat64;
  request : JobRequest;
  created_at : nat64;
  gas_fees : nat64;
  commit_ids : vec nat64;
};
type JobRequest = record {
  transaction_hash : opt text;
  block_hash : opt text;
  data : blob;
  chain : Chain;
  on_chain_id : opt nat;
  block_number : opt nat64;
  function_hash : blob;
  gas_payment : nat;
  caller : Address;
};
type JobStatus = variant {
  Failed : text;
  Executing;
  Waiting;
  Completed;
  Pending;
};
type LogEntry = record { level : LogType; message : text };
type LogType = variant { System; Default };
type Result = variant { Ok : vec JobRequest; Err : text };
type Result_1 = variant { Ok : SignerInfo; Err : text };
type Result_2 = variant { Ok : SimulationResult; Err : text };
type Result_3 = variant { Ok; Err : text };
type SignerInfo = record { public_key : text; eth_address : text };
type SimulationResult = record {
  job : Job;
  error : opt text;
  commits : vec Commit;
};
service : {
  // Deploy a new function.
  deploy_function : (FunctionDefinition, opt text) -> (DeployResult);
  get_commit : (nat64) -> (opt Commit) query;
  get_evm_address : () -> (text) query;
  // Retrieve function definition and state by its ID.
  get_function : (blob) -> (opt FunctionState) query;
  get_job : (Chain, nat) -> (opt Job) query;
  // Looks for jobs in the specified block on the given chain.
  // TODO: Currently this call is exposed to the public and invoked from the frontend.
  // This is problematic as the call incurs costs the RPC and could be used to drain cycles.
  // In the future we could require addition of cycles to the call that are refunded only
  // if new jobs were found in the block. We should also provide an (off chain?) indexer to
  // watch for new blocks and call this method automatically.
  index_block : (Chain, nat64) -> (Result);
  signer_for_caller : (Caller, opt blob) -> (Result_1) query;
  signer_for_function : (blob, opt blob) -> (Result_1) query;
  simulate_execution : (JobRequest, blob) -> (Result_2) query;
  tmp_set_api_keys : (text, opt vec text) -> (Result_3);
}
